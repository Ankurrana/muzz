# Muzz - A Simple Dating App

Welcome to Muzz, a simple yet effective dating app designed to connect you with potential matches. This README provides details on how to interact with Muzz's API to create a user, log in, discover users, and swipe on users.

## Table of Contents
- [Create New User](#create-new-user)
- [Login User](#login-user)
- [Discover Users](#discover-users)
- [Swipe User](#swipe-user)
- [Using the Makefile](#using-the-makefile)

## Create New User

To create a new user, send a POST request to the `/user/create` endpoint with the user's details in the request body.

### Request
```sh
curl --location 'localhost:8000/user/create' \
--header 'Content-Type: application/json' \
--data-raw '{
    "name": "User1",
    "email": "user1@gmail.com",
    "password": "user123",
    "age": 15,
    "gender": "male",
    "lat": 32.4124,
    "lon": 32.742
}'
```
## Login User

To log in, send a POST request to the `/login` endpoint with the user's email and password.

### Request
```sh
curl --location 'localhost:8000/login' \
--header 'Content-Type: application/json' \
--data-raw '{
    "email": "user1@gmail.com",
    "password": "user123"
}'
```

## Discover Users

To discover users, send a GET request to the `/discover` endpoint with the user's token in the authorization header. You can also include query parameters to filter users by age range and gender.

### Request
```sh
curl --location --request GET 'localhost:8000/discover?min_age=18&max_age=30&gender=female' \
--header 'Authorization: Bearer ${token_user_1}' \
--header 'Content-Type: application/json'
```

## Swipe User

To swipe on a user, send a POST request to the `/swipe` endpoint with the user's token in the authorization header and the swiped user's ID and preference in the request body.

### Request
```sh
curl --location 'localhost:8000/swipe' \
--header 'Authorization: Bearer ${token_user_1}' \
--header 'Content-Type: application/json' \
--data '{
    "user_id": 3,
    "preference": "yes"
}'
```


## Using the Makefile

The provided Makefile contains various commands to help manage and interact with the Muzz application. Below are the details on how to use these commands.

### Running the Application

To run the application, use the following command:
```sh
make run
```

### Adding Users

To add predefined users, use the following commands:

```sh
make add_user1
make add_user2
make add_user3
make add_user4
```

### Logging in Users
To log in predefined users, use the following commands:

```
make login_user1
make login_user2
make login_user3
make login_user4
```


### Discovering Users
Make sure to update the tokens generated by the login curl in the makefile using the output token generated by the login_user_1 command
To discover users with various filters, use the following commands:

```
token_user_1 = ???
token_user_2 = ???
token_user_3 = ???
token_user_4 = ???

make dis_user1     # Discover all users
make dis_user2     # Discover users with min_age=20
make dis_user3     # Discover users with min_age=20 and max_age=30
make dis_user4     # Discover users with min_age=20, max_age=30, and gender=male
```


### Swiping Users
To swipe on users, use the following commands:

```
make swipe_1_3     # User 1 swipes yes on User 3
make swipe_3_1     # User 3 swipes yes on User 1
```


### Cleaning the Database
```
    make clean_db
```


### Assumptions, Improvements and Points to Note
1. The Discover API will return all possible matches for the user, ignoring users who have already been swiped right. This approach is not ideal for large-scale systems. To handle a large number of users, we need to use pagination with custom rank sorting. Using a function scoring system like Elasticsearch would be more effective.
2. Login JWT tokens are valid for 1 hour.
3. A dummy hashing algorithm is currently used to hash passwords for storage in the database. This dummy algorithm simply returns the plain password. It can be easily extended to use modern hashing algorithms.
4. Unit testing is done only for some parts of the code. This is to demonstrate the good design of the code with an appropriate level of abstractions, making it easy to write unit tests for any part of the system.
5. Ideally, user-friendly errors should be returned, but this has been ignored for the scope of this exercise.
6. I focused on good code architecture and ensuring all requested use cases are covered. I limited myself to one day to complete this code, resulting in some trade-offs. For example, unit testing, error handling, API versioning, logging levels, request tracing, rate limiting, code linting, and benchmarking are areas that could be significantly improved.
7. I'd love to have a detailed discussion on how to improve this code for scalability. Maybe we can discuss how to design architecture for scale in the interview.